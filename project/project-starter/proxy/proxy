#!/usr/bin/env python2.7
import sys
import socket
import re
import thread
import select
import time
import xml.etree.ElementTree as ET

DELIMIT_CHAR = "\r\n\r\n" # Character delimiting end of message
SERVER_BIND_PORT = 4999
BUFFER_SIZE = 1024
BITRATE_MAP = {}

# Creating a method to be called later
def connect_to_server(proxy_ip, server_ip,):
    global SERVER_BIND_PORT
    # server_socket.close()
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((proxy_ip, SERVER_BIND_PORT))
    server_socket.connect((server_ip, 8080))
    SERVER_BIND_PORT += 1
    return server_socket

# Returns a dictionary mapping the bitrates to their URL's from the manifest file
def get_bitrates(server_socket, message):
    global BITRATE_MAP

    if len(BITRATE_MAP) != 0:
        return

    manifest_response = send_to_server(server_socket, message)

    # Cut out the HTTP header from the manifest
    body_length = manifest_response[2]
    header_length = len(manifest_response[0]) - body_length - len(DELIMIT_CHAR)
    manifest_body = manifest_response[0][header_length:]

    # Cut out the first <?xml line
    manifest_body = "\n".join(manifest_body.split("\n")[1:])

    bitrate_array = manifest_body.split("<media")
    bitrate_dict = {}
    for bitrate_element in bitrate_array:
        result = re.search("url=\"(.+)\"\n.+bitrate=\"(.+)\"", bitrate_element)
        if result != None:
            bitrate_dict[int(result.groups()[1])] = result.groups()[0]

    BITRATE_MAP = bitrate_dict

# Logic that handles sending the client message to the server
# Returns the response from the server, whether or not the server connection is closed,
# and the length of the chunk (via Content-Length)
def send_to_server(server_socket, client_message):
    client_first_get = client_message.split('\n')[0]
    get_request = client_first_get + "\nHost: " + server_ip + "\n\n"
    print "get_request: ", client_first_get
    server_socket.sendall(get_request)

    while True:
        data = server_socket.recv(BUFFER_SIZE)

        while len(select.select([server_socket], [], [], 1)[0]) > 0:
            ready_server_socket = select.select([server_socket], [], [], 1)[0][0]
            data += ready_server_socket.recv(BUFFER_SIZE)

        # print "Receiving data from server"

        if data:
            result = re.search("Content-Length: (\d+)", data.split(DELIMIT_CHAR)[0])
            return [data + DELIMIT_CHAR, True, int(result.groups()[0])]
        else:
            print "Server terminated the connection"
            return [data + DELIMIT_CHAR, False, 0]

# Logic that handles accepting a client connection
# Returns whether or not the proxy should be kept alive or not
def handle_from_client(log_path, alpha, client_socket, client_address, proxy_ip, server_ip):
    try:
        server_socket = connect_to_server(proxy_ip, server_ip)
        with open(log_path, "w") as f:
            # Scope the following variables to be accessible across the entire method
            throughput_avg = -1

            while True:
                data = client_socket.recv(BUFFER_SIZE)
                while len(select.select([client_socket], [], [], 1)[0]) > 0:
                    ready_client_socket = select.select([client_socket], [], [], 1)[0][0]
                    data += ready_client_socket.recv(BUFFER_SIZE)

                start_time = time.time()
                # print "Received data from client"

                if data:
                    # Make sure proxy cuts off the message at delimiter character
                    message = data.split(DELIMIT_CHAR)[0] + DELIMIT_CHAR
                    result = re.search("^(GET )(.+)( HTTP.+)", message.split('\n')[0])
                    response = [None, None, None]

                    try:
                        # Change manifest
                        if result.groups()[1] == "/vod/big_buck_bunny.f4m":
                            get_bitrates(server_socket, message)
                            message_remaining = "\n".join(message[1:])
                            message = result.groups()[0] + "/vod/big_buck_bunny_nolist.f4m" + result.groups()[2] + message_remaining
                            response = send_to_server(server_socket, message)
                        elif len(BITRATE_MAP) > 0 and result.groups()[1].startswith("/vod"):
                            bitrate_search = re.search("/vod/\d+(Seg.+)", result.groups()[1])
                            chunk_name = None

                            if throughput_avg != -1:
                                bitrates = BITRATE_MAP.keys()
                                max_bitrate = float(throughput_avg) / 1.5
                                calculated_rate = 0
                                for bitrate in bitrates:
                                    if bitrate < max_bitrate and max_bitrate - bitrate < max_bitrate - calculated_rate:
                                        calculated_rate = bitrate
                                if calculated_rate == 0:
                                    calculated_rate = min(bitrates)

                                chunk_name = "/vod/" + BITRATE_MAP[calculated_rate] + bitrate_search.groups()[0]
                                message_remaining = "\n".join(message[1:])
                                message = result.groups()[0] + chunk_name + result.groups()[2] + message_remaining
                            else:
                                # For logging
                                chunk_name = result.groups()[1]
                            response = send_to_server(server_socket, message)

                            # Throughput Calculation
                            end_time = time.time()
                            duration = float(end_time - start_time)

                            chunk_size = float(response[2]) * 8 / 1000 # bytes -> kilobits
                            throughput_new = chunk_size / duration

                            if throughput_avg == -1:
                                throughput_avg = throughput_new # Initialize to first value
                            else:
                                throughput_avg = alpha * throughput_new + (1 - alpha) * throughput_avg

                            log = time.time() + " " + duration + " " + throughput_new + " " + throughput_avg + " " + calculated_rate + " " + server_ip + " " + chunk_name
                            print log
                            f.write(log)
                            f.flush()
                        else:
                            response = send_to_server(server_socket, message)

                        # Send the response back to the client
                        client_socket.sendall(response[0])

                        # Check if server terminated, if so reconnect
                        if response[1] == False:
                            server_socket = connect_to_server(proxy_ip, server_ip)
                    except Exception, e:
                        print "handle_from_client exception:", e
                        client_socket.close()
                        server_socket.close()
                        f.close()
                        return
                else:
                    print "Client terminated the connection"
                    client_socket.close()
                    server_socket.close()
                    f.close()
                    return
    except Exception, e:
        print "Exception inside handle_from_client: ", e
        client_socket.close()
        f.close()
        return

### Start of execution

# Input arguments
log_path = sys.argv[1]
alpha = float(sys.argv[2])
listen_port = int(sys.argv[3])
proxy_ip = sys.argv[4] # Fake IP
server_ip = sys.argv[5]

# Proxy listen socket to handle client browsers (proxy acts as server)
c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
c.bind(('', listen_port))
c.listen(1)

while True:
    try:
        # TODO: Lock on the log

        client_socket, client_address = c.accept()
        print "Received a connection"
        thread.start_new_thread(handle_from_client, (log_path, alpha, client_socket, client_address, proxy_ip, server_ip))
    except KeyboardInterrupt:
        c.close()
        break
    except Exception, e:
        c.close()
        print "Exception at proxy client level: ", e
        break
