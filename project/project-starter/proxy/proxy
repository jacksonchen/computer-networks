#!/usr/bin/env python2.7
import sys
import socket
import re
import thread
import select
import time

DELIMIT_CHAR = "\r\n\r\n" # Character delimiting end of message
SERVER_BIND_PORT = 4999
BUFFER_SIZE = 1024

# Creating a method to be called later
def connect_to_server(proxy_ip, server_ip,):
    global SERVER_BIND_PORT
    # server_socket.close()
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((proxy_ip, SERVER_BIND_PORT))
    server_socket.connect((server_ip, 8080))
    SERVER_BIND_PORT += 1
    return server_socket

# Logic that handles sending the client message to the server
# Returns the response from the server, whether or not the server connection is closed,
# and the length of the chunk (via Content-Length)
def send_to_server(server_socket, client_message):
    client_first_get = client_message.split('\n')[0]
    get_request = client_first_get + "\nHost: " + server_ip + "\n\n"
    print "get_request: ", get_request
    server_socket.sendall(get_request)

    # message = ""
    # expected_length = -1
    while True:
        data = server_socket.recv(BUFFER_SIZE)

        while len(select.select([server_socket], [], [], 1)[0]) > 0:
            ready_server_socket = select.select([server_socket], [], [], 1)[0][0]
            data += ready_server_socket.recv(BUFFER_SIZE)

        print "Receiving data from server"
        # print data

        if data:
            result = re.search("Content-Length: (\d+)", data.split(DELIMIT_CHAR)[0])
            return [data + DELIMIT_CHAR, True, int(result.groups()[0])]
            # if expected_length == -1 and DELIMIT_CHAR in data: # To differentiate the header from the body
            #     header = data.split(DELIMIT_CHAR)[0]

            #
            #     # Add header to the message
            #     message += data
            #     body_length = len(data) - len(data.split(DELIMIT_CHAR)[0]) - len(DELIMIT_CHAR)
            #     expected_length = int(result.groups()[0]) - body_length
            #     print "expected_length: ", expected_length
            # else: # Handling the body
            #     expected_length = max(expected_length - len(data), 0)
            #     print "expected_length: ", expected_length
            #     message += data
            #
            #     # Using Content-Length to find the end of message
            #     if expected_length == 0:
            #         print "RETURNING MESSAGE"
            #         # print message
            #         return [message + DELIMIT_CHAR, True]
        else:
            print "Server terminated the connection"
            return [data + DELIMIT_CHAR, False, 0]

# Logic that handles accepting a client connection
# Returns whether or not the proxy should be kept alive or not
def handle_from_client(log_path, alpha, client_socket, client_address, proxy_ip, server_ip):
    try:
        server_socket = connect_to_server(proxy_ip, server_ip)
        throughput_avg = -1 # Scope the variable to be method accessible

        while True:
            data = client_socket.recv(BUFFER_SIZE)
            while len(select.select([client_socket], [], [], 1)[0]) > 0:
                ready_client_socket = select.select([client_socket], [], [], 1)[0][0]
                data += ready_client_socket.recv(BUFFER_SIZE)
                print data

            start_time = time.time()
            print "Received data from client"
            # print data

            if data:
                # Make sure proxy cuts off the message at delimiter character
                message = data.split(DELIMIT_CHAR)[0] + DELIMIT_CHAR

                result = re.search("^(GET )(.+)( HTTP.+)", message.split('\n')[0])

                # Change manifest
                if result.groups()[1] == "vod/big_buck_bunny.f4m":
                    message_remaining = "\n".join(message[1:])
                    message = result.groups()[0] + "vod/big_buck_bunny_nolist.f4m" + result.groups()[2] + message_remaining

                response = send_to_server(server_socket, message)

                # Throughput Calculation
                end_time = time.time()
                chunk_size = float(response[2])
                throughput_new = chunk_size / float(end_time - start_time)

                if throughput_avg == -1:
                    throughput_avg = throughput_new # Initialize to first value
                else:
                    throughput_avg = alpha * throughput_new + (1 - alpha) * throughput_avg

                # Send the response back to the client
                client_socket.sendall(response[0])

                # Check if server terminated, if so reconnect
                if response[1] == False:
                    server_socket = connect_to_server(proxy_ip, server_ip)
            else:
                print "Client terminated the connection"
                client_socket.close()
                server_socket.close()
                return
    except Exception, e:
        print "Exception inside handle_from_client: ", e
        client_socket.close()
        server_socket.close()
        return

### Start of execution

# Input arguments
log_path = sys.argv[1]
alpha = float(sys.argv[2])
listen_port = int(sys.argv[3])
proxy_ip = sys.argv[4] # Fake IP
server_ip = sys.argv[5]

# Proxy listen socket to handle client browsers (proxy acts as server)
c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
c.bind(('', listen_port))
c.listen(1)

while True:
    try:
        # TODO: Lock on the log

        client_socket, client_address = c.accept()
        print "Received a connection"
        thread.start_new_thread(handle_from_client, (log_path, alpha, client_socket, client_address, proxy_ip, server_ip))

        # try:
        #     keep_alive = handle_from_client(client_socket)
        #     client_connection.close()
        # finally:
        #     client_connection.close()
    except KeyboardInterrupt:
        c.close()
        break
    except Exception, e:
        c.close()
        print "Exception at proxy client level: ", e
        break
