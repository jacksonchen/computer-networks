#!/usr/bin/env python2.7
import sys
import socket
import re

DELIMIT_CHAR = "\r\n\r\n" # Character delimiting end of message
SERVER_BIND_PORT = 4999

# Input arguments
log_path = sys.argv[1]
alpha = float(sys.argv[2])
listen_port = int(sys.argv[3])
proxy_ip = sys.argv[4] # Fake IP
server_ip = sys.argv[5]

# Proxy to handle client (proxy acts as server)
c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
c.bind(('', listen_port))
c.listen(1)

# Proxy to direct to server (proxy acts as client)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((proxy_ip, SERVER_BIND_PORT))
s.connect((server_ip, 8080))
SERVER_BIND_PORT += 1

# Creating a method to be called later
def connect_to_server():
    s.close()
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((proxy_ip, SERVER_BIND_PORT))
    s.connect((server_ip, 8080))
    SERVER_BIND_PORT += 1

# Logic that handles sending the client message to the server
# Returns the response from the server
def send_to_server(client_message):
    client_first_get = client_message.split('\n')[0]
    get_request = client_first_get + "\nHost: " + server_ip + "\n\n"
    print "get_request: ", get_request
    s.sendall(get_request.encode())

    message = ""
    expected_length = -1
    while True:
        data = s.recv(1024).decode()
        print "Receiving data from server"
        # print data

        if data:
            if expected_length == -1 and DELIMIT_CHAR in data: # To differentiate the header from the body
                header = data.split(DELIMIT_CHAR)[0]
                result = re.search("Content-Length: (\d+)", header)

                # Add header to the message
                message += data
                body_length = len(data) - len(data.split(DELIMIT_CHAR)[0]) - len(DELIMIT_CHAR)
                expected_length = int(result.groups()[0]) - body_length
                print "expected_length: ", expected_length
            else: # Handling the body
                expected_length = max(expected_length - len(data), 0)
                print "expected_length: ", expected_length
                message += data

                # Using Content-Length to find the end of message
                if expected_length == 0:
                    print "RETURNING MESSAGE"
                    print message
                    return [message + DELIMIT_CHAR, True]
        else:
            print "Server terminated the connection"
            print "expected_length: ", expected_length
            return [message + DELIMIT_CHAR, False]

# Logic that handles accepting a client connection
# Returns whether or not the proxy should be kept alive or not
def handle_from_client(client_connection):
    message = ""
    while True:
        data = client_connection.recv(1024).decode()
        print "Received data from client"
        print data

        if data:
            if DELIMIT_CHAR in data:
                message += data.split(DELIMIT_CHAR)[0]
                server_message = message + DELIMIT_CHAR # Add the newline character for formatting

                try:
                    response = send_to_server(server_message)
                    client_connection.sendall(response[0].encode())
                    message = ""

                    if response[1] == False: # Server terminated, thus reconnect
                        connect_to_server()
                except Exception as e:
                    print "Exception!", e
                    return False # Server timed out or errored, thus end proxy
            else:
                message += data
        else:
            print "Client terminated the connection"
            return False

while True:
    try:
        client_connection, client_address = c.accept()
        print "Received a connection"

        try:
            keep_alive = handle_from_client(client_connection)
            # if (not keep_alive):
            client_connection.close()
                # break
        finally:
            client_connection.close()
    except KeyboardInterrupt:
        s.close()
        c.close()
