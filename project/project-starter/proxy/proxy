#!/usr/bin/env python2.7
import sys
import socket
import re

DELIMIT_CHAR = "\r\n\r\n" # Character delimiting end of message

# Input arguments
log_path = sys.argv[1]
alpha = float(sys.argv[2])
listen_port = int(sys.argv[3])
proxy_ip = sys.argv[4] # Fake IP
server_ip = sys.argv[5]

# Proxy to handle client (proxy acts as server)
c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
c.bind(('', listen_port))
c.listen(1)

# Proxy to direct to server (proxy acts as client)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((proxy_ip, 4999))
s.connect((server_ip, 8080))
server_connected = True

# Logic that handles sending the client message to the server
# Returns the response from the server
def send_to_server(client_message):
    client_first_get = client_message.split('\n')[0]
    get_request = client_first_get + "\nHost: " + server_ip + "\n\n"
    print "get_request: ", get_request
    s.sendall(get_request.encode())

    message = ""
    expected_length = -1
    while True:
        data = s.recv(1024).decode()
        print "Receiving data from server"
        print data

        if data:
            if expected_length == -1 and DELIMIT_CHAR in data: # To differentiate the header from the body
                header = data.split(DELIMIT_CHAR)[0]
                result = re.search("Content-Length: (\d+)", header)

                # Add header to the message
                message += data
                body_length = len(data) - len(data.split(DELIMIT_CHAR)[0]) - len(DELIMIT_CHAR)
                expected_length = int(result.groups()[0]) - body_length
            elif expected_length == 0: # Using Content-Length to find the end of message
                print "===== message\n", message
                return message + DELIMIT_CHAR
            else:
                expected_length = max(expected_length - len(data), 0)
                message += data
        else:
            print "Server terminated the connection"
            return message + DELIMIT_CHAR

# Logic that handles accepting a client connection
# Returns whether or not the proxy should be kept alive or not
def handle_from_client(client_connection):
    message = ""
    while True:
        data = client_connection.recv(1024).decode()
        print "Received data from client"
        print data

        if data:
            if DELIMIT_CHAR in data:
                message += data.split(DELIMIT_CHAR)[0]
                server_message = message + DELIMIT_CHAR # Add the newline character for formatting

                try:
                    response = send_to_server(server_message)
                    if response == DELIMIT_CHAR:
                        return False # Server terminated, thus end proxy
                    else:
                        client_connection.sendall(response.encode())
                        message = ""
                except:
                    return False # Server timed'out or errorer, thus end proxy
            else:
                message += data
        else:
            print "Client terminated the connection"
            return True

while server_connected:
    try:
        client_connection, client_address = c.accept()
        print "Received a connection"

        try:
            keep_alive = handle_from_client(client_connection)
            if (not keep_alive):
                client_connection.close()
                break
        finally:
            client_connection.close()
    except KeyboardInterrupt:
        s.close()
        c.close()

s.close()
c.close()
